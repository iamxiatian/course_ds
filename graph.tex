\section{Graph}

\begin{frame}[fragile]{Graph}
  \begin{adjustbox}{max totalsize={.9\textwidth}{.7\textheight},center}
    \tikzstyle{every node}=[circle, draw, fill=black!50,
    inner sep=0pt, minimum width=4pt]
    % Tutte's 8-cage
    \begin{tikzpicture}[thick,scale=0.8]
      \draw \foreach \x in {0,36,...,324}
      {
        (\x:2) node {}  -- (\x+108:2)
        (\x-10:3) node {} -- (\x+5:4)
        (\x-10:3) -- (\x+36:2)
        (\x-10:3) --(\x+170:3)
        (\x+5:4) node {} -- (\x+41:4)
      };
    \end{tikzpicture}\quad

    % The largest 3-regular graph of diameter 3
    \begin{tikzpicture}[thick,scale=0.8]%
      \draw \foreach \x in {18,90,...,306} {
        (\x:4) node{} -- (\x+72:4)
        (\x:4) -- (\x:3) node{}
        (\x:3) -- (\x+15:2) node{}
        (\x:3) -- (\x-15:2) node{}
        (\x+15:2) -- (\x+144-15:2)
        (\x-15:2) -- (\x+144+15:2)
      };
    \end{tikzpicture}
  \end{adjustbox}
\end{frame}

\begin{frame}[fragile]{Content}
  \begin{easylist} \easyitem
    & 图的定义
    & 图的存储表示
    & 图的遍历
    & 图的连通性
  \end{easylist}
\end{frame}

\begin{frame}[fragile]
  \frametitle{图的用途}
  \begin{easylist}
    & 用数学语言来说，网络通常被视为一种加权图（Weighted Graph），其中节点（Node）代表实体，边（Edge）代表实体间的关系，而边的权重（Weight）则代表了这种关系的某种度量（如距离、成本、流量等）。

    & 除了数学上的定义，网络还具有实际的物理含义，它是从相同类型的实际问题中抽象出来的模型。这些实际问题包括但不限于交通系统、物流运输、通信系统等，因此习惯上会根据其应用领域称之为相应的网络类型，如交通网络、运输网络、通信网络等。

    & 现实生活中的许多问题，如交通路线的优化、ERP（企业资源规划）系统的工作计划制定等，都可以借助图与网络的模型进行建模和求解。这些模型能够帮助我们更好地理解和分析问题的本质，从而找到有效的解决方案。
  \end{easylist}
\end{frame}

\begin{frame}[fragile]
  \frametitle{社会网络(social network)}
  \small
  \begin{easylist}
    & 社会网络是指由社会个体成员之间因互动而形成的相对稳定的关系体系。
    & 社会网络分析（SNA）作为社会学的一个重要分支，自上世纪30年代末起逐步发展，成为研究社会结构的重要方法和技术。从30年代到60年代，这一领域吸引了来自心理学、社会学、人类学以及数学、物理、统计、概率等领域的学者，他们共同推动了SNA的理论、方法和技术的发展，使其成为研究社会结构的重要范式。
  \end{easylist}
\end{frame}

\begin{frame}[fragile, allowframebreaks]
  \frametitle{六度分隔(Six Degrees of Separation)}
  \small
  \begin{easylist}
    & 六度空间理论（也称为小世界现象或六度分隔理论）最初是在1929年由匈牙利作家弗里奇斯·卡林思（Frigyes Karinthy）在他的短篇小说中提出的，他提出世界上所有人都可以通过至多五个中间人联系起来。

    & 1967年，哈佛大学的社会心理学教授Stanley Milgram (1933-1984)进行了一项著名的实验来验证这一理论。他设计了一个连锁信件实验，从Nebraska和Kansas随机选择了300多名志愿者，请他们寄一封信函给指定的一名住在波士顿的股票经纪人。实验结果表明，有六十多封信函最终到达了目标人手中，并且这些信函在传递过程中经过的中间人的数目平均只有大约5个。这一发现验证了六度空间理论，并使其受到了全世界的广泛关注。

    \newpage
    
    & 此外，Milgram还发现了漏斗效应，即大部分的信件传递都是由少数几个“明星人物”完成的，这些人在社交网络中具有很高的连接性，能够更快地传递信息。

    & 六度空间理论不仅激发了学术界的深入研究，还催生了电影《六度空间》（又称《六度分离》或《连锁反应》）等文化产品，进一步增强了公众对这一理论的兴趣和认知。
  \end{easylist}
\end{frame}

\begin{frame}[fragile, allowframebreaks]
  \frametitle{150法则(Rule of 150)}
  \begin{easylist}
    & 从欧洲发源的“赫特兄弟会”是一个自给自足的农民自发组织，他们有一个不成文的
    严格规定：每当聚居人数超过150人的规模，他们就把它变成两个，再各自发展。

    & 150也被称为“邓巴数字(Dunbar’s number)”，该理论认为人的大脑新皮层大小有限，
    提供的认知能力只能使一个人维持与大约150人的稳定人际关系。

    & 把人群控制在150人以下似乎是管理人群的一个最佳和最有效的方式。早期中国移动的动
    感地带sim卡最多保存150个手机号，早期一个MSN帐号只能对应150个联系人。

    & 不管你认识多少人，或者与更多人建立了弱链接，那些强链接仍然在此次此刻符合
    150法则。这也符合“二八”法则，即80\%的社会活动可能被150个强链接所占有。
  \end{easylist}
\end{frame}

\begin{frame}[fragile, allowframebreaks]
  \frametitle{网络模型}
  \begin{easylist}
    & 随机网络：
    && 在交通网络中，随机网络可以模拟道路拥堵的情况。假设道路的连接（箭线）和交叉口（节点）的实现具有一定的随机性，这取决于交通流量、道路状况等多种因素。
    && 用途：随机网络用于描述那些节点和连接具有不确定性的系统。在交通网络中，随机网络模型可以帮助预测和规划交通流量，优化交通设计，减少拥堵。此外，随机网络还广泛应用于计算机科学、社会学、生物学等领域，用于模拟和分析各种复杂系统的行为。
    \newpage
    & 小世界网络
    && 社交网络可以看作是一个小世界网络。在社交网络中，虽然大多数人只与少数人保持紧密联系（短路径），但几乎每个人都可以通过少数几个熟人联系到网络中的任何其他人（小世界现象）。
    && 用途：小世界网络模型用于描述那些具有较短的平均路径长度和较高的聚类系数的网络。这种网络结构使得信息在网络中传播得非常快，因此小世界网络模型在信息传播、社交网络分析、推荐系统等领域具有广泛应用。此外，小世界网络还用于研究生物网络、神经网络等复杂系统的行为。
    \newpage
    & 无标度网络
    && 互联网可以看作是一个无标度网络。在互联网中，少数大型网站（Hub点）拥有大量的链接，而大多数网站只有少量的链接。这种网络结构使得互联网呈现出无标度性，即节点的连接数（度数）分布严重不均匀。
    && 用途：无标度网络模型用于描述那些具有严重不均匀分布特性的网络。在互联网中，无标度网络模型有助于理解网络的拓扑结构、稳定性和鲁棒性等特性。此外，无标度网络还广泛应用于社交网络、金融网络、生物网络等领域的研究，以揭示这些复杂系统的内在规律和运行机制。
  \end{easylist}
\end{frame}

\begin{frame}[fragile]
  \frametitle{图(Graph)}
  \begin{itemize}
  \item 图$G=(V, E)$, $V$是顶点(Vertex)集合,$E$是边/弧(Edge/Arc)的集合.
  \item 顶点的度、出度和入度
  \end{itemize}

  \begin{columns}[T]
    \column{0.5\textwidth}
    有向图：
    
    \begin{tikzpicture}[scale=1.0]
      \GraphInit[vstyle=Art]
      \Vertex{A}
      \Vertex[x=4,y=0]{B}
      \Vertex[x=0,y=2]{C}
      \Vertex[x=4,y=2]{D}
      \Edge[style={-Latex}](A)(D)

      \Edges[style={-Latex}](A,B,C, D)
      \Edges[style={-Latex}](A, C)
    \end{tikzpicture}
    
    \column{0.5\textwidth}
    无向图：
    
    \begin{tikzpicture}[scale=1.0]
      \GraphInit[vstyle=Art]
      \Vertex{A}
      \Vertex[x=4,y=0]{B}
      \Vertex[x=0,y=2]{C}
      \Vertex[x=4,y=2]{D}
      \Edge[style={}](A)(D)

      \Edges[style={}](A,B,C, D)
      \Edges[style={}](A, C)
    \end{tikzpicture}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{图的相关概念}
  \includegraphics[width=0.9\textwidth]{figs/graph_concept.png}
\end{frame}

\begin{frame}[plain]
~  
\end{frame}

\begin{frame}[fragile]
  \frametitle{图的存储}
  如何表达下图的信息?
  \begin{columns}
    \column{0.4\textwidth}
    有向图：
    
    \begin{tikzpicture}[scale=1.3]
      \GraphInit[vstyle=Normal]
      \begin{scope}[rotate=180]
        \Vertices{circle}{$v_1$, $v_2$, $v_3$, $v_4$}
      \end{scope}
      \Edges[style={-Latex}]($v_1$,  $v_3$, $v_4$, $v_1$, $v_2$)
    \end{tikzpicture}
    
    \column{0.4\textwidth}
    无向图：
    
    \begin{tikzpicture}[scale=1.5]
      \GraphInit[vstyle=Normal]
      \begin{scope}[rotate=180]
        \Vertices{circle}{$v_1$, $v_2$, $v_3$, $v_4$}
      \end{scope}
      \Vertex{$v_5$}
      \Edges($v_1$, $v_2$, $v_3$, $v_4$, $v_1$)
      \Edges($v_2$, $v_5$, $v_3$)
    \end{tikzpicture}
  \end{columns}
  
  \pause
  \begin{itemize}
  \item 可用邻接矩阵表达顶点及其关系。
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{图的存储}
  \small
  \begin{columns}[T]
    \column{0.4\textwidth}
    \begin{tikzpicture}[scale=1]
      \GraphInit[vstyle=Normal]
      \begin{scope}[rotate=180]
        \Vertices{circle}{$v_1$, $v_2$, $v_3$, $v_4$}
      \end{scope}
      \Edges[style={-Latex}]($v_1$,  $v_3$, $v_4$, $v_1$, $v_2$)
    \end{tikzpicture}
    \[
      \begin{blockarray}{ccccc}
         & v_1 & v_2 & v_3 & v_4 \\
        \begin{block}{c (c c c c)}
          v_1 & 0 & 1 & 1 & 0 \\
          v_2 & 0 & 0 & 0 & 0 \\
          v_3 & 0 & 0 & 0 & 1 \\
          v_4 & 1 & 0 & 0 & 0 \\
        \end{block}
      \end{blockarray}
    \]

    \column{0.4\textwidth}
    \begin{tikzpicture}[scale=1.0]
      \GraphInit[vstyle=Normal]
      \begin{scope}[rotate=180]
        \Vertices{circle}{$v_1$, $v_2$, $v_3$, $v_4$}
      \end{scope}
      \Vertex{$v_5$}
      \Edges($v_1$, $v_2$, $v_3$, $v_4$, $v_1$)
      \Edges($v_2$, $v_5$, $v_3$)
    \end{tikzpicture}

    \[
      \begin{blockarray}{cccccc}
         & v_1 & v_2 & v_3 & v_4 & v_5 \\
        \begin{block}{c (c c c c c)}
          v_1 & 0 & 1 & 0 & 1 & 0 \\
          v_2 & 1 & 0 & 1 & 0 & 1 \\
          v_3 & 0 & 1 & 0 & 1 & 1 \\
          v_4 & 1 & 0 & 1 & 0 & 0 \\
          v_5 & 0 & 1 & 1 & 0 & 0 \\
        \end{block}
      \end{blockarray}
    \]    
  \end{columns}
  
  \begin{itemize}
  \item 根据邻接矩阵,如何判断各顶点的度?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{有向图的连续存储方式：邻接矩阵}
  \begin{columns}[T]
    \column{0.4\textwidth}
    \begin{tikzpicture}[scale=1.4]
      \GraphInit[vstyle=Normal]
      \begin{scope}[rotate=180]
        \Vertices{circle}{$v_1$, $v_2$, $v_3$, $v_4$}
      \end{scope}
      \Edges[style={-Latex}]($v_1$,  $v_3$, $v_4$, $v_1$, $v_2$)
    \end{tikzpicture}
    \[
      \begin{blockarray}{ccccc}
        & v_1 & v_2 & v_3 & v_4 \\
        \begin{block}{c (c c c c)}
          v_1 & 0 & 1 & 1 & 0 \\
          v_2 & 0 & 0 & 0 & 0 \\
          v_3 & 0 & 0 & 0 & 1 \\
          v_4 & 1 & 0 & 0 & 0 \\
        \end{block}
      \end{blockarray}
    \]
    
    \column{0.6\textwidth}
    \begin{itemize}
    \item 建立二维数组$A[n][n]$, $n=|V|$
    \item 另需存放$n$个顶点信息
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{网的邻接矩阵}
  \begin{columns}[T]
    \column{0.4\textwidth}
    \begin{tikzpicture}[scale=1.8]
      \GraphInit[vstyle=Normal]
      \begin{scope}[rotate=180]
        \Vertices{circle}{v1, v2, v3, v4}
      \end{scope}
      \Edge[label = 8, style={-Latex}](v1)(v2)
      \Edge[label = 3, style={-Latex}](v1)(v3)
      \Edge[label = 5, style={-Latex}](v4)(v1)
      \Edge[label = 1, style={-Latex}](v3)(v4)
    \end{tikzpicture}
    \[
      \begin{blockarray}{ccccc}
        & v_1 & v_2 & v_3 & v_4 \\
        \begin{block}{c (c c c c)}
          v_1 & \infty & 8 & 3 & \infty \\
          v_2 & \infty & \infty & \infty & \infty \\
          v_3 & \infty & \infty & \infty & 1 \\
          v_4 & 5 & \infty & \infty & \infty \\
        \end{block}
      \end{blockarray}
    \]
    
    \column{0.6\textwidth}
    \begin{itemize}
    \item 有些图的边带有权重(常用来表示成本、距离、时间等), 这样的图称为：{\color{red} 网}。
    \item 网的邻接矩阵表达权重,没有边的顶点之间的权重默认为$\infty$
    \item 邻接矩阵表示方法非常直观、简单,但是会有什么问题? \pause
    \item 现实中的图经常对应稀疏矩阵,在这样情形下会有很大空间浪费.
    \end{itemize}
  \end{columns}  
\end{frame}

\begin{frame}[fragile]
  \frametitle{邻接表 (Adjacency List) -- 无向图}
  \begin{columns}[T]
    \column{0.35\textwidth}
    \begin{tikzpicture}[scale=1.3]
      \GraphInit[vstyle=Normal]
      \begin{scope}[rotate=90]
        \Vertices{circle}{v1, v2, v3, v4}
      \end{scope}
      \Edges(v3, v1, v2, v4)
    \end{tikzpicture}
    
    \column{0.6\textwidth}
    \scalebox{0.8}{
      \begin{tikzpicture}[ n/.style={minimum height=0.8cm, minimum width=1cm},
        n2/.style={minimum height=0.6cm, minimum width=1cm, fill=red!5},
        e/.style={->, very thick}]
        \draw node[n] (n0) {索引} node[n,right=0 of n0](label) {头节点};

        \foreach \x  [evaluate = \x as \xp using int(\x-1)] in {1, ..., 4}
        \draw node[n, below=0 of n\xp](n\x) {$\xp$};

        \foreach \x/\y/\z in {1/A/,2/B/,3/C/,4/D/}
        \draw node[n, right=0 of n\x, draw, fill=yellow!10](\y) {$v_\x$} node[n, right=0 of \y, draw] (P\y) {\z};


        \draw node[n2, draw, right=of PA] (c11) {2} node[n2, draw, right=0 of c11] (c12) {};
        \draw node[n2, draw, right=of c12] (c21) {1} node[n2, draw, right=0 of c21] (c22) {$\wedge$};
        \draw[e] (PA.center) -- (c11);
        \draw[e] (c12.center)--(c21);

        \draw node[n2, draw, right=of PB] (c11) {3} node[n2, draw, right=0 of c11] (c12) {};
        \draw node[n2, draw, right=of c12] (c21) {0} node[n2, draw, right=0 of c21] (c22) {$\wedge$};
        \draw[e] (PB.center) -- (c11) (c12.center)--(c21);

        \draw node[n2, draw, right=of PC] (c11) {0} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PC.center) -- (c11);

        \draw node[n2, draw, right=of PD] (c11) {1} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PD.center) -- (c11);
      \end{tikzpicture}
    }
  \end{columns}

  \begin{itemize}
  \item 无向图的邻接表:同一个顶点发出的边链接在同一个边链表中,便于确定顶点的度
  \item 需要$n$个头结点, $2e$个表结点
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{邻接表--有向图}
  \begin{columns}[T]
    \column{0.4\textwidth}
    \begin{tikzpicture}[scale=1.5]
      \GraphInit[vstyle=Normal]
      \begin{scope}[rotate=135]
        \Vertices{circle}{A, B, C, E}
      \end{scope}
      \Vertex{D}
      \Edges[style={-Latex}](A, B, C, D, E, A)
      \Edge[style={-Latex}](A)(D)	
    \end{tikzpicture}
    
    邻接表,便于确定节点出度

    \scalebox{0.7}{
      \begin{tikzpicture}[ n/.style={minimum height=0.8cm, minimum width=1cm},
        n2/.style={minimum height=0.6cm, minimum width=1cm, fill=red!5},
        e/.style={->, very thick}]
        \draw node[n] (n0) {索引} node[n,right=0 of n0](label) {头节点};

        \foreach \x  [evaluate = \x as \xp using int(\x-1)] in {1, ..., 5}
        \draw node[n, below=0 of n\xp](n\x) {$\xp$};

        \foreach \x/\y/\z in {1/A/,2/B/,3/C/,4/D/, 5/E/}
        \draw node[n, right=0 of n\x, draw, fill=yellow!10](\y) {$\y$} node[n, right=0 of \y, draw] (P\y) {\z};


        \draw node[n2, draw, right=of PA] (c11) {3} node[n2, draw, right=0 of c11] (c12) {};
        \draw node[n2, draw, right=of c12] (c21) {1} node[n2, draw, right=0 of c21] (c22) {$\wedge$};
        \draw[e] (PA.center) -- (c11);
        \draw[e] (c12.center)--(c21);

        \draw node[n2, draw, right=of PB] (c11) {2} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PB.center) -- (c11);

        \draw node[n2, draw, right=of PC] (c11) {3} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PC.center) -- (c11);

        \draw node[n2, draw, right=of PD] (c11) {4} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PD.center) -- (c11);

        \draw node[n2, draw, right=of PE] (c11) {0} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PE.center) -- (c11);
      \end{tikzpicture}
    }
    \pause
    
    \column{0.6\textwidth}
    逆邻接表,便于确定节点入度
    
    \scalebox{0.7}{
      \begin{tikzpicture}[ n/.style={minimum height=0.8cm, minimum width=1cm},
        n2/.style={minimum height=0.6cm, minimum width=1cm, fill=red!5},
        e/.style={->, very thick}]
        \draw node[n] (n0) {索引} node[n,right=0 of n0](label) {头节点};

        \foreach \x  [evaluate = \x as \xp using int(\x-1)] in {1, ..., 5}
        \draw node[n, below=0 of n\xp](n\x) {$\xp$};

        \foreach \x/\y/\z in {1/A/,2/B/,3/C/,4/D/, 5/E/}
        \draw node[n, right=0 of n\x, draw, fill=yellow!10](\y) {$\y$} node[n, right=0 of \y, draw] (P\y) {\z};

        \draw node[n2, draw, right=of PA] (c11) {4} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PA.center) -- (c11);

        \draw node[n2, draw, right=of PB] (c11) {0} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PB.center) -- (c11);

        \draw node[n2, draw, right=of PC] (c11) {1} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PC.center) -- (c11);

        \draw node[n2, draw, right=of PD] (c11) {2} node[n2, draw, right=0 of c11] (c12) {};
        \draw node[n2, draw, right=of c12] (c21) {0} node[n2, draw, right=0 of c21] (c22) {$\wedge$};
        \draw[e] (PD.center) -- (c11);
        \draw[e] (c12.center)--(c21);

        \draw node[n2, draw, right=of PE] (c11) {3} node[n2, draw, right=0 of c11] (c12) {$\wedge$};
        \draw[e] (PE.center) -- (c11);
      \end{tikzpicture}
    }    
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{邻接表--权重处理}
  \scalebox{0.7}{
    \begin{tikzpicture}[scale=2]
      \GraphInit[vstyle=Normal]
      \begin{scope}[rotate=225]
        \Vertices{circle}{A, B, D, C}
      \end{scope}

      \Edge[style={-Latex}, label=1](A)(B)
      \Edge[style={-Latex, pos=0.2}, label=4](A)(D)

      \Edge[style={-Latex, pos=0.2, bend right}, label=9](B)(C)
      \Edge[style={-Latex}, label=2](B)(D)

      \Edge[style={-Latex}, label=3](C)(A)
      \Edge[style={-Latex, pos=0.2, bend right=10}, label=5](C)(B)
      \Edge[style={-Latex}, label=8](C)(D)

      \Edge[style={-Latex, bend right=40}, label=6](D)(C)
    \end{tikzpicture}
  }

  \scalebox{0.7}{
    \begin{tikzpicture}[ n/.style={minimum height=0.8cm, minimum width=1cm},
      n2/.style={minimum height=0.6cm, minimum width=1cm, fill=red!5},
      e/.style={->, very thick}]
      \draw node[n] (n0) {索引} node[n,right=0 of n0](label) {头节点};

      \foreach \x  [evaluate = \x as \xp using int(\x-1)] in {1, ..., 4}
      \draw node[n, below=0 of n\xp](n\x) {$\xp$};

      \foreach \x/\y/\z in {1/A/,2/B/,3/C/,4/D/}
      \draw node[n, right=0 of n\x, draw, fill=yellow!10](\y) {$\y$} node[n, right=0 of \y, draw] (P\y) {\z};

      \draw node[n2, draw, right=of PA] (c11) {1} node[n2, draw, right=0 of c11,fill=blue!10] (c12) {1} node[n2, draw, right=0 of c12] (c13) {};
      \draw node[n2, draw, right=of c13] (c21) {3}  node[n2, draw, right=0 of c21,fill=blue!10] (c22) {4} node[n2, draw, right=0 of c22] (c23) {$\wedge$};
      \draw[e] (PA.center) -- (c11);
      \draw[e] (c13.center) -- (c21);

      \draw node[above=of c11](tip1) {边的终点} node[right=of tip1](tip2){权重};
      \path[draw, ->] (tip1) edge (c11) (tip2) edge[bend right] (c12);
      
      \draw node[n2, draw, right=of PB] (c11) {3} node[n2, draw, right=0 of c11,fill=blue!10] (c12) {2} node[n2, draw, right=0 of c12] (c13) {};
      \draw node[n2, draw, right=of c13] (c21) {2}  node[n2, draw, right=0 of c21,fill=blue!10] (c22) {9} node[n2, draw, right=0 of c22] (c23) {$\wedge$};
      \draw[e] (PB.center) -- (c11);
      \draw[e] (c13.center) -- (c21);

      \draw node[n2, draw, right=of PC] (c11) {0} node[n2, draw, right=0 of c11,fill=blue!10] (c12) {3} node[n2, draw, right=0 of c12] (c13) {};
      \draw node[n2, draw, right=of c13] (c21) {1}  node[n2, draw, right=0 of c21,fill=blue!10] (c22) {5} node[n2, draw, right=0 of c22] (c23) {};
      \draw node[n2, draw, right=of c23] (c31) {3}  node[n2, draw, right=0 of c31,fill=blue!10] (c32) {8} node[n2, draw, right=0 of c32] (c33) {$\wedge$};
      \draw[e] (PC.center) -- (c11);
      \draw[e] (c13.center) -- (c21);
      \draw[e] (c23.center) -- (c31);

      \draw node[n2, draw, right=of PD] (c11) {2} node[n2, draw, right=0 of c11,fill=blue!10] (c12) {6} node[n2, draw, right=0 of c12] (c13) {$\wedge$};
      \draw[e] (PD.center) -- (c11);
    \end{tikzpicture}
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{练习}
  \begin{enumerate}
  \item 请写出数组存储和邻接表的类型定义
  \item 请在如下方面对比数组表示法和邻接表示法
    \begin{itemize}
    \item 存储表示是否唯一
    \item 空间复杂度
    \item 操作a: 求顶点$v_i$的度
    \item 操作b: 判定$(v_i, v_j)$是否是图的一条边
    \item 操作c: 通过遍历求边的数目
    \end{itemize}
  \end{enumerate}
\end{frame}
% TODO

\begin{frame}[fragile, allowframebreaks]
  \frametitle{邻接表表示}
  \scriptsize
  \begin{minted}{java}
    class VertexNode {
      String data;
      EdgeNode firstAdj = null;

      public VertexNode(String data) {
        this.data = data;
      }
    }

    class EdgeNode {
      int adjVertexNode;
      EdgeNode nextAdj = null;

      public EdgeNode(int vertexIdx) {
        this.adjVertexNode = vertexIdx;
      }

      public EdgeNode(int vertexIdx, EdgeNode nextAdj) {
        this.adjVertexNode = vertexIdx;
        this.nextAdj = nextAdj;
      }
    }
    
    public class Graph {
      VertexNode[] vertices;

      public void init() {
        this.vertices = new VertexNode[]{
          new VertexNode("v1"),
          new VertexNode("v2"),
          new VertexNode("v3"),
          new VertexNode("v4"),
          new VertexNode("v5"),
          new VertexNode("v6"),
          new VertexNode("v7"),
          new VertexNode("v8")
        };
        vertices[0].firstAdj = new EdgeNode(1, new EdgeNode(2));
        vertices[1].firstAdj = new EdgeNode(0, new EdgeNode(3, new EdgeNode(4)));
        vertices[2].firstAdj = new EdgeNode(0, new EdgeNode(5, new EdgeNode(6)));
        vertices[3].firstAdj = new EdgeNode(1, new EdgeNode(7));
        vertices[4].firstAdj = new EdgeNode(1, new EdgeNode(7));
        vertices[5].firstAdj = new EdgeNode(2, new EdgeNode(6));
        vertices[6].firstAdj = new EdgeNode(2, new EdgeNode(5));
        vertices[7].firstAdj = new EdgeNode(3, new EdgeNode(4));
      }
    }
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{比较}
  \small
  \begin{tabular}{| p{2cm} | p{4cm} | p{4cm} |}
    \hline
    ~ & 数组表示法 & 邻接表法 \\ \hline
    表示结果 & 唯一 & 不唯一 \\ \hline
    空间复杂度 & $O(n^2)$ (适用于稠密图) & $O(n+e)$ (适用于稀疏图) \\ \hline
    无向图求顶点$v_i$的度 & 第$i$行(或第$i$列)上非零元素的个数 & 第$i$个边表中的结点个数 \\ \hline
    有向图求顶点$v_i$的度  & 第$i$行上非零元素的个数是$v_i$出度,第$i$列上非零元素的个数是$v_i$的入度 & 第$i$个边表上的结点个数,求入度还需遍历各顶点的边表。逆邻接表则相反\\ \hline
    判定$(v_i, v_j)$是否是图的一条边 &  看矩阵中的$i$行$j$列是否为0 & 扫描第i个边表 \\ \hline
    求边的数目 & 检测整个矩阵中的非零元所耗费的时间是$O(N^2)$ & 对每个边表的结点个数计数所耗费的时间是$O(e+n)$ \\ \hline
  \end{tabular}  
\end{frame}

\begin{frame}[fragile]
  \frametitle{思考}

  怎么把邻接表和逆邻接表相结合,同时表示出来?
\end{frame}

\begin{frame}[fragile]
  \frametitle{有向图的十字链表(Orthogonal List)}
  \begin{columns}[T]
    \column{0.4\textwidth}
    \scalebox{0.6}{
      \begin{tikzpicture}[
          % 定义样式
          node distance = 2cm,
          auto,
          every node/.style={
            circle,
            draw,
            font=\sffamily\Large\bfseries
          },
          edge/.style={draw,->,thick}
        ]
        % 定义节点
        \node (v0) at (0,0) {$v_0$};
        \node[right=of v0] (v1) {$v_1$};
        \node[below left=of v0] (v2) {$v_2$};
        \node[below right=of v0] (v3) {$v_3$};

        % 绘制边
        \path[edge] (v0) -- (v1);
        \path[edge, bend right] (v0) to (v2);
        \path[edge, bend right] (v2) to (v0);
        \path[edge] (v2) -- (v3);
        \path[edge] (v3) -- (v0);
        \path[edge] (v3) -- (v1);
      \end{tikzpicture}
    }
    \column{0.6\textwidth}
    将邻接表、逆邻接表结合起来.
    \begin{itemize}
    \item hlink: 指向弧头相同的下一条弧
    \item tlink: 指向弧尾相同的下一条弧
    \end{itemize}
  \end{columns}
  \scalebox{0.7}{
    \begin{tikzpicture}[ n/.style={minimum height=0.8cm, minimum width=1cm},
        n2/.style={minimum height=0.6cm, minimum width=1cm, fill=red!5},
        n3/.style={minimum height=0.6cm, minimum width=1cm},
        e/.style={->, thick, red},
        e2/.style={->, thick, blue}]
      \draw node[n] (n0) {索引} node[n,right=0 of n0](label) {头节点};

      \foreach \x  [evaluate = \x as \xp using int(\x-1)] in {1, ..., 4}
      \draw node[n, below=0 of n\xp](n\x) {$\xp$};

      \foreach \x/\y/\z/\i/\v in {1/A//0/,2/B//1/,3/C//2/,4/D//3/}
      \draw node[n, right=0 of n\x, draw, fill=yellow!10](\y) {$v_\i$} node[n, right=0 of \y, draw] (firstIn\y) {\z} node[n, right=0 of firstIn\y, draw] (firstOut\y) {\v};

      \draw node[n2, draw, right=of firstOutA] (headAB) {0} node[n2, draw, right=0 of headAB] (tailAB) {1} node[n3, draw, right=0 of tailAB] (headLinkAB) {} node[n3, draw, right=0 of headLinkAB] (tailLinkAB) {};

      \draw node[n2, draw, right=of tailLinkAB] (headAC) {0} node[n2, draw, right=0 of headAC] (tailAC) {2} node[n3, draw, right=0 of tailAC] (headLinkAC) {} node[n3, draw, right=0 of headLinkAC] (tailLinkAC) {$\wedge$};

      \draw node[n2, draw, right=of firstOutC] (headCA) {2} node[n2, draw, right=0 of headCA] (tailCA) {0} node[n3, draw, right=0 of tailCA] (headLinkCA) {} node[n3, draw, right=0 of headLinkCA] (tailLinkCA) {};

      \draw node[n2, draw, right=of tailLinkCA] (headCD) {2} node[n2, draw, right=0 of headCD] (tailCD) {3} node[n3, draw, right=0 of tailCD] (headLinkCD) {} node[n3, draw, right=0 of headLinkCD] (tailLinkCD) {};

      \draw node[n2, draw, right=of firstOutD] (headDA) {3} node[n2, draw, right=0 of headDA] (tailDA) {0} node[n3, draw, right=0 of tailDA] (headLinkDA) {$\wedge$} node[n3, draw, right=0 of headLinkDA] (tailLinkDA) {};

      \draw node[n2, draw, right=of tailLinkDA] (headDB) {3} node[n2, draw, right=0 of headDB] (tailDB) {1} node[n3, draw, right=0 of tailDB] (headLinkDB) {} node[n3, draw, right=0 of headLinkDB] (tailLinkDB) {};

      \draw[] node[above=1.5cm of firstInA](tipFirstIn) {$firstIn$} node[right=0 of tipFirstIn] (tipFirstOut) {$firstOut$} 
      node[above=1cm of headAB] (tipHeadAB) {$tailVertex$} node[above=1.5cm of tailAB] (tipTailAB) {$headVertex$}
      node[above=1cm of headLinkAB] (tipHeadLinkAB) {$hlink$} node[right=0 of tipHeadLinkAB] (tipTailLinkAB) {$tlink$};

      % draw tip of node
      \path[draw, <-, dashed] (tipFirstIn) edge (firstInA) 
      (tipFirstOut) edge[bend right] (firstOutA)
      (tipHeadAB) edge[] (headAB)
      (tipTailAB) edge[bend left] (tailAB)
      (tipHeadLinkAB) edge[bend left] (headLinkAB)
      (tipTailLinkAB) edge[bend left] (tailLinkAB); 

      % draw links
      \path[e] (firstInA.center) edge[bend left=45, out=120] (headLinkCA.north);
      \draw[e] (headLinkCA.center) -- (headLinkDA.north);
      \draw[e2] (firstOutA.center) -- (headAB);
      \draw[e2] (tailLinkAB.center) -- (headAC);
    \end{tikzpicture}
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{有向图的十字链表}
  \begin{columns}
    \column{0.5\textwidth}
    \begin{minted}[fontsize=\scriptsize]{java}
      class VertexNode {
        String data;
        ArcBox firstIn;
        ArcBox firstOut;
      }

      class ArcBox {
        int headVertex, tailVertex;
        ArcBox hlink;
        ArcBox tlink;
        String data;
      }
    \end{minted}
    \column{0.5\textwidth}
    \begin{minted}[fontsize=\small]{java}
      class OLGraph {
        List<VertexNode> xlist;
        int vertexNum, arcNum;
      }
    \end{minted}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{无向图的多重邻接表}
  \begin{columns}[T]
    \column{0.3\textwidth}
    \begin{tikzpicture}[scale=1.2]
      \GraphInit[vstyle=Normal]
      \SetVertexMath
      \begin{scope}[rotate=135]
        \Vertices{circle}{v_0, v_2, v_3, v_1}
      \end{scope}
      \Edges[](v_0, v_1, v_3, v_2, v_0, v_3)
    \end{tikzpicture}

    \column{0.7\textwidth}
    \small
    \begin{itemize}
    \item 无向图的应用中，关注的重点是顶点，那么邻接表是不错的选择
    \item 如更关注边的操作，比如对已访问过的边做标记，删除某一条边等操作，就意味着需要找到这条边的两个边表结点进行操作。
    \end{itemize}
  \end{columns}

  \begin{tabular}{|c|c|c|c}
    \hline
    $ivex$ & $ilink$ & $jvex$ & $jlink$ \\ \hline
  \end{tabular}
  
  \begin{itemize}
  \item $ivex$, $jvex$: 某条边依附的两个顶点
  \item $ilink$: 指向依附顶点$ivex$的下一条边
  \item $jlink$: 指向依附顶点$jvex$的下一条边
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{无向图的多重邻接表}
  \begin{columns}[T]
    \column{0.3\textwidth}
    \begin{tikzpicture}[scale=1.2]
      \GraphInit[vstyle=Normal]
      \SetVertexMath
      \begin{scope}[rotate=135]
        \Vertices{circle}{v_0, v_2, v_3, v_1}
      \end{scope}
      \Edges[](v_0, v_1, v_3, v_2, v_0, v_3)
    \end{tikzpicture}

    \column{0.7\textwidth}
    \small
    \begin{itemize}
    \item 无向图的应用中，关注的重点是顶点，那么邻接表是不错的选择
    \item 如更关注边的操作，比如对已访问过的边做标记，删除某一条边等操作，就意味着需要找到这条边的两个边表结点进行操作。
    \end{itemize}
  \end{columns}

  \scalebox{0.7}{
    \begin{tikzpicture}[ n/.style={minimum height=0.8cm, minimum width=1cm},
      n2/.style={minimum height=0.6cm, minimum width=1cm, fill=red!5},
      n3/.style={minimum height=0.6cm, minimum width=1cm},
      e/.style={draw, ->, thick, red},
      e2/.style={draw, ->, thick, blue}]
      \draw node[n] (n0) {索引} node[n,right=0 of n0](label) {头节点};

      \foreach \x  [evaluate = \x as \xp using int(\x-1)] in {1, ..., 4}
      \draw node[n, below=0 of n\xp](n\x) {$\xp$};

      \foreach \x/\y/\z in {1/A/v_0,2/B/v_1,3/C/v_2,4/D/v_3}
      \draw node[n, right=0 of n\x, draw, fill=yellow!10](\y) {$\z$} node[n, right=0 of \y, draw] (firstEdge\y) {};

      \draw node[n2, draw, right=of firstEdgeA] (ivexAB) {0} node[n3, draw, right=0 of ivexAB] (ilinkAB) {} node[n2, draw, right=0 of ilinkAB] (jvexAB) {1} node[n3, draw, right=0 of jvexAB] (jlinkAB) {};
      \draw node[n2, draw, right=of jlinkAB] (ivexAC) {0} node[n3, draw, right=0 of ivexAC] (ilinkAC) {} node[n2, draw, right=0 of ilinkAC] (jvexAC) {2} node[n3, draw, right=0 of jvexAC] (jlinkAC) {};
      \draw node[n2, draw, below=0.5 of jvexAC] (ivexAD) {0} node[n3, draw, right=0 of ivexAD] (ilinkAD) {$\wedge$} node[n2, draw, right=0 of ilinkAD] (jvexAD) {3} node[n3, draw, right=0 of jvexAD] (jlinkAD) {$\wedge$};
      

      \draw node[n2, draw, right=of firstEdgeD] (ivexDB) {3} node[n3, draw, right=0 of ivexDB] (ilinkDB) {} node[n2, draw, right=0 of ilinkDB] (jvexDB) {1} node[n3, draw, right=0 of jvexDB] (jlinkDB) {};

      \draw node[n2, draw, right=of jlinkDB] (ivexDC) {3} node[n3, draw, right=0 of ivexDC] (ilinkDC) {} node[n2, draw, right=0 of ilinkDC] (jvexDC) {2} node[n3, draw, right=0 of jvexDC] (jlinkDC) {};


      \draw[] node[above=1.5cm of firstEdgeA](tipFirstEdge) {$firstEdge$}  
      node[above=1cm of ivexAB] (tipivex) {$ivex$} node[above=1.5cm of jvexAB] (tipjvex) {$jvex$}
      node[above=1cm of ilinkAB] (tipilink) {$ilink$} node[right=0 of tipjvex] (tipjlink) {$jlink$};

      \path[draw, ->, dashed] (firstEdgeA) edge (tipFirstEdge)
      (ivexAB) edge (tipivex)
      (ilinkAB) edge (tipilink)
      (jvexAB) edge (tipjvex)
      (jlinkAB) edge (tipjlink);

      \path[e] (firstEdgeA.center) -- (ivexAB);
      \draw[e] (ilinkAB.center) to[out=90,in=180] (ivexAC);
      \draw[e] (ilinkAC.center) to[out=270, in=180] (ivexAD.west);

      \path[e] (firstEdgeD.center) -- (ivexDB);
      \draw[e] (ilinkDB.center) to[out=270,in=180] (ivexDC);
      \draw[e] (ilinkDC.center) to[out=90,in=220] (ivexAD);

    \end{tikzpicture}
  }
\end{frame}

\subsection{图的遍历}
\begin{frame}[fragile]
  \frametitle{图的遍历}
  ~
\end{frame}

\begin{frame}[fragile]
  \frametitle{图的遍历}

  图的遍历:从图的某顶点出发,访问所有顶点,且每个顶点仅被访问一次。
  
  无论是无向图还是有向图，都有两种遍历方式：
  \begin{columns}[T]
    \column{0.6\textwidth}
    \begin{itemize}
    \item 深度优先(类似于树的先根遍历)
    \item 广度优先(类似于树的层次遍历)
    \end{itemize}
    
    \column{0.6\textwidth}
    \scalebox{0.7}{
      \begin{tikzpicture}[scale=1]
        \GraphInit[vstyle=Normal]
        \SetVertexMath
        \Vertex{v_1}
        \Vertex[x=-2, y=-1]{v_2}
        \Vertex[x=1.5, y=-1]{v_3}

        \SOWE(v_2){v_4}
        \SOEA(v_2){v_5}


        \SOWE(v_3){v_6}
        \SOEA(v_3){v_7}
        \SOWE(v_5){v_8}

        \Edges(v_1,v_2,v_4,v_8,v_5,v_2)
        \Edges(v_1,v_3,v_6,v_7,v_3)
      \end{tikzpicture}
    }
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{深度优先搜索 - Depth First Search}

  \begin{columns}[T]
    \column{0.65\textwidth}
    \scalebox{0.8}{
      \begin{tikzpicture}[scale=1]
        \GraphInit[vstyle=Normal]
        \SetVertexMath
        \Vertex{v_1}
        \Vertex[x=-2, y=-1]{v_2}
        \Vertex[x=1.5, y=-1]{v_3}

        \SOWE(v_2){v_4}
        \SOEA(v_2){v_5}


        \SOWE(v_3){v_6}
        \SOEA(v_3){v_7}
        \SOWE(v_5){v_8}

        \Edges(v_1,v_2,v_4,v_8,v_5,v_2)
        \Edges(v_1,v_3,v_6,v_7,v_3)
      \end{tikzpicture}
    }

    以$v_1$开始为例：$v_1 \rightarrow v_2 \rightarrow v_4 \rightarrow v_8
    \rightarrow v_5 \rightarrow \cdots$
    
    \scalebox{0.8}{
      \begin{tikzpicture}[ n/.style={minimum size=0.8cm}]
        \draw node[] (n0) {};
        \foreach \x  [evaluate = \x as \xp using int(\x-1)] in {1, ..., 8}
        \draw node[n, right=0 of n\xp](n\x) {$v_\x$};

        \foreach \x/\y in {1/1,2/1,3/0,4/1,5/1, 6/0, 7/0, 8/1}
        \draw node[n, below=0 of n\x, draw, fill=red!5](d\x) {$\y$};

        \draw node[left=0 of d1]{$visited$};

        \foreach \x/\y in {1/v_1,2/v_2,3/v_4,4/v_8,5/v_5, 6/, 7/, 8/}
        \draw node[n, below=0.3 of d\x, draw, fill=yellow!20](d\x) {$\y$};

        \draw node[left=0 of d1]{$stack$};
      \end{tikzpicture}
    }
    
    \column{0.35\textwidth}
    \begin{tabular}{| l | l |}
      \hline
      $v_1$ & $\rightarrow v_2 \rightarrow v_3$ \\ \hline
      $v_2$ & $\rightarrow v_1 \rightarrow v_4 \rightarrow v_5$ \\ \hline
      $v_3$ & $\rightarrow v_1 \rightarrow v_6 \rightarrow v_7$ \\ \hline
      $v_4$ & $\rightarrow v_2 \rightarrow v_8$ \\ \hline
      $v_5$ & $\rightarrow v_2 \rightarrow v_8$ \\ \hline
      $v_6$ & $\rightarrow v_3 \rightarrow v_7$ \\ \hline
      $v_7$ & $\rightarrow v_3 \rightarrow v_6$ \\ \hline
      $v_8$ & $\rightarrow v_4 \rightarrow v_5$ \\ \hline      
    \end{tabular}
  \end{columns}

  \pause
  
  $v_1 \rightarrow v_2 \rightarrow v_4 \rightarrow v_8
  \rightarrow v_5$ \color{red} $\rightarrow v_3 \rightarrow v_6 \rightarrow v_7$  
\end{frame}

\begin{frame}[fragile, plain, allowframebreaks]
  %\frametitle{DFS}
  \begin{minted}[fontsize=\scriptsize]{java}
    class VertexNode {
      String data;
      EdgeNode firstAdj = null;

      public VertexNode(String data) {
        this.data = data;
      }
    }

    class EdgeNode {
      int adjVertexNode;
      EdgeNode nextAdj = null;

      public EdgeNode(int vertexIdx) {
        this.adjVertexNode = vertexIdx;
      }

      public EdgeNode(int vertexIdx, EdgeNode nextAdj) {
        this.adjVertexNode = vertexIdx;
        this.nextAdj = nextAdj;
      }
    }
    
    public class Graph {
      VertexNode[] vertices;

      public void init() {
        this.vertices = new VertexNode[]{
          new VertexNode("v1"),
          new VertexNode("v2"),
          new VertexNode("v3"),
          new VertexNode("v4"),
          new VertexNode("v5"),
          new VertexNode("v6"),
          new VertexNode("v7"),
          new VertexNode("v8")
        };
        vertices[0].firstAdj = new EdgeNode(1, new EdgeNode(2));
        vertices[1].firstAdj = new EdgeNode(0, new EdgeNode(3, new EdgeNode(4)));
        vertices[2].firstAdj = new EdgeNode(0, new EdgeNode(5, new EdgeNode(6)));
        vertices[3].firstAdj = new EdgeNode(1, new EdgeNode(7));
        vertices[4].firstAdj = new EdgeNode(1, new EdgeNode(7));
        vertices[5].firstAdj = new EdgeNode(2, new EdgeNode(6));
        vertices[6].firstAdj = new EdgeNode(2, new EdgeNode(5));
        vertices[7].firstAdj = new EdgeNode(3, new EdgeNode(4));
      }
      
      void dfsTraverse() {
        boolean[] visited = new boolean[vertices.length];
        //for (int i = 0; i < visited.length; i++) visited[i] = false;
        for (int v = 0; v < vertices.length; v++) { //why for?
          if (!visited[v]) dfs(v, visited);
        }
      }

      void dfs(int v, boolean[] visited) {
        visited[v] = true;
        VertexNode vertex = vertices[v];
        System.out.print(vertex.data + " ");

        for (EdgeNode w = vertex.firstAdj; w != null; w = w.nextAdj) {
          if (!visited[w.adjVertexNode])
          dfs(w.adjVertexNode, visited);
        }
      }

      public static void main(String[] args) {
        Graph g = new Graph();
        g.init();
        g.dfsTraverse();
      }
    }
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{图不一定连通,需要遍历每一个节点}
  \includegraphics[width=0.9\textwidth]{figs/graph_dfs.png}
\end{frame}

\begin{frame}[fragile]
  \frametitle{DFS算法分析}
  \begin{itemize}
  \item 比较两种存储结构下的算法 (设 n 个顶点, e 条边)
    \begin{itemize}
    \item 数组表示:查找每个顶点的邻接点要遍历每一行,遍历的时间复杂度为$O(n^2)$
    \item 邻接表表示:虽然有 $2e$个表结点,但只需扫描$e$个结点即可完成遍历,加上访
      问$n$个头结点的时间,遍历的时间复杂度为$O(n+e)$
    \end{itemize}
  \item 结论：
    \begin{itemize}
    \item 稠密图适于在邻接矩阵上进行深度遍历;
    \item 稀疏图适于在邻接表上进行深度遍历。
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{广度优先搜索 - Breadth First Search}
\begin{columns}[T]
    \column{0.65\textwidth}
    \scalebox{0.8}{
      \begin{tikzpicture}[scale=1]
        \GraphInit[vstyle=Normal]
        \SetVertexMath
        \Vertex{v_1}
        \Vertex[x=-2, y=-1]{v_2}
        \Vertex[x=1.5, y=-1]{v_3}

        \SOWE(v_2){v_4}
        \SOEA(v_2){v_5}


        \SOWE(v_3){v_6}
        \SOEA(v_3){v_7}
        \SOWE(v_5){v_8}

        \Edges(v_1,v_2,v_4,v_8,v_5,v_2)
        \Edges(v_1,v_3,v_6,v_7,v_3)
      \end{tikzpicture}
    }

    \scalebox{0.8}{
      \begin{tikzpicture}[ n/.style={minimum size=0.8cm}]
        \draw node[] (n0) {};
        \foreach \x  [evaluate = \x as \xp using int(\x-1)] in {1, ..., 8}
        \draw node[n, right=0 of n\xp](n\x) {$v_\x$};

        \foreach \x/\y in {1/1,2/0,3/0,4/0,5/0, 6/0, 7/0, 8/0}
        \draw node[n, below=0 of n\x, draw, fill=red!5](d\x) {$\y$};

        \draw node[left=0 of d1]{$visited$};

        \foreach \x/\y in {1/v_2,2/v_3,3/,4/,5/, 6/, 7/, 8/}
        \draw node[n, below=0.3 of d\x, draw, fill=yellow!20](d\x) {$\y$};

        \draw node[left=0 of d1]{$queue$};
      \end{tikzpicture}
    }
    
    \column{0.35\textwidth}
    \begin{tabular}{| l | l |}
      \hline
      $v_1$ & $\rightarrow v_2 \rightarrow v_3$ \\ \hline
      $v_2$ & $\rightarrow v_1 \rightarrow v_4 \rightarrow v_5$ \\ \hline
      $v_3$ & $\rightarrow v_1 \rightarrow v_6 \rightarrow v_7$ \\ \hline
      $v_4$ & $\rightarrow v_2 \rightarrow v_8$ \\ \hline
      $v_5$ & $\rightarrow v_2 \rightarrow v_8$ \\ \hline
      $v_6$ & $\rightarrow v_3 \rightarrow v_7$ \\ \hline
      $v_7$ & $\rightarrow v_3 \rightarrow v_6$ \\ \hline
      $v_8$ & $\rightarrow v_4 \rightarrow v_5$ \\ \hline      
    \end{tabular}
  \end{columns}

  \pause
  
  $v_1 \rightarrow v_2 \rightarrow v_3 \rightarrow v_4
  \rightarrow v_5 \rightarrow v_6 \rightarrow v_7 \rightarrow v_8$  
\end{frame}

\begin{frame}[allowframebreaks, fragile]
  \frametitle{BFS}

  \begin{minted}[fontsize=\small]{java}
    void bfs() {
      boolean[] visited = new boolean[vertices.length];
      //for (int i = 0; i < visited.length; i++) visited[i] = false;

      Queue<Integer> Q = new LinkedList<>();
      for (int v = 0; v < vertices.length; v++) {
        if (!visited[v]) {
          visited[v] = true;
          System.out.print(vertices[v].data + " ");
          Q.add(v);

          while (!Q.isEmpty()) {
            int u = Q.poll();

            for (EdgeNode w = vertices[u].firstAdj; w != null; w = w.nextAdj) {
              if (!visited[w.adjVertexNode]) {
                visited[w.adjVertexNode] = true;
                System.out.print(vertices[w.adjVertexNode].data + " ");
                Q.add(w.adjVertexNode);
              }
            }
          }
        }
      }
    }
  \end{minted}  
\end{frame}

\begin{frame}[fragile, allowframebreaks]
  \frametitle{分析以下代码的输出结果}
  
 \begin{minted}[fontsize=\small]{java}
    void bfs() {
        boolean[] visited = new boolean[vertices.length];
        //for (int i = 0; i < visited.length; i++) visited[i] = false;

        Queue<Integer> Q = new LinkedList<>();
        for (int v = 0; v < vertices.length; v++) {
            if (!visited[v]) {
                Q.add(v);
            }

            while (!Q.isEmpty()) {
                int u = Q.poll();

                visited[u] = true;
                System.out.print(vertices[u].data + " ");

                for (EdgeNode w = vertices[u].firstAdj; w != null; w = w.nextAdj) {
                    if (!visited[w.adjVertexNode]) {
                        Q.add(w.adjVertexNode);
                    }
                }
            }
        }
    }
 \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{BFS算法分析}
  \begin{itemize}
  \item 数组表示:BFS对于每一个被访问到的顶点,都要循环检测矩阵中的整整一行(n个元
    素),总的时间代价为$O(n^2)$
  \item 邻接表表示:时间复杂度$O(n+e)$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{作业练习}
  \begin{enumerate}
  \item 请写出如下有向图的邻接矩阵,基于该矩阵进行图的深度优先遍历;
  \item 建立如下有向图的邻接表,进行图的广度优先遍历.
  \end{enumerate}

  \scalebox{0.8}{
    \begin{tikzpicture}[scale=1.5]
      \GraphInit[vstyle=Normal]
      \SetVertexMath

      \Vertex{3} \NOWE(3){0} \NOEA(3){1} \SOWE(3){5} \SOEA(3){6} 

      \Vertex[x=-2, y=0] {2} 	\Vertex[x=2, y=0] {4}

      \Edges[style={-Latex}](0,1,4,6,5)
      \Edges[style={-Latex}](0,2,5)
      \Edges[style={-Latex}](0,3,5)
      \Edges[style={-Latex}](1,3,6)
      \Edges[style={-Latex}](4,3,2)
    \end{tikzpicture}
  }
\end{frame}


\subsection{图的连通性}
\begin{frame}[fragile]
  \frametitle{图的连通性}

  图的连通性在计算机网、通信网和电力网等方面有着重要的应用。
\end{frame}

\begin{frame}[fragile]
  \frametitle{生成树(Spanning tree)}
  \begin{columns}[T]
    \column{0.5\textwidth}
    深度优先生成树：

    \scalebox{0.8}{      
      \begin{tikzpicture}[scale=1]
        \GraphInit[vstyle=Normal]
        \SetVertexMath
        \Vertex{v_1}
        \Vertex[x=-2, y=-1]{v_2}
        \Vertex[x=1.5, y=-1]{v_3}

        \SOWE(v_2){v_4}
        \SOEA(v_2){v_5}


        \SOWE(v_3){v_6}
        \SOEA(v_3){v_7}
        \SOWE(v_5){v_8}

        \Edges[color=red](v_1,v_2,v_4,v_8,v_5,v_2)
        \Edges[color=red](v_1,v_3,v_6,v_7,v_3)
        \Edges(v_3,v_7)
        \Edges(v_2,v_5)
      \end{tikzpicture}   
    }
    \column{0.5\textwidth}
    广度优先生成树：

    \scalebox{0.8}{      
      \begin{tikzpicture}[scale=1]
        \GraphInit[vstyle=Normal]
        \SetVertexMath
        \Vertex{v_1}
        \Vertex[x=-2, y=-1]{v_2}
        \Vertex[x=1.5, y=-1]{v_3}

        \SOWE(v_2){v_4}
        \SOEA(v_2){v_5}


        \SOWE(v_3){v_6}
        \SOEA(v_3){v_7}
        \SOWE(v_5){v_8}

        \Edges[color=red](v_1,v_2,v_4,v_8,v_5,v_2)
        \Edges[color=red](v_1,v_3,v_6,v_7,v_3)
        \Edges(v_5,v_8)
        \Edges(v_6,v_7)
      \end{tikzpicture}   
    }
  \end{columns}
  连通图的生成树是它的极小连通子图,有$n$个顶点和$n-1$条边。
\end{frame}

\begin{frame}[fragile]
  \frametitle{非连通图的连通分量}

  对于非连通图，则遍历生成森林

  \scalebox{0.8}{    
    \begin{tikzpicture}[scale=1]
      \GraphInit[vstyle=Normal]
      \SetVertexMath
      \Vertex{v_1}
      \Vertex[x=-2, y=-1]{v_2}
      \Vertex[x=1.5, y=-1]{v_3}

      \SOWE(v_2){v_4}
      \SOEA(v_2){v_5}


      \SOWE(v_3){v_6}
      \SOEA(v_3){v_7}
      \SOWE(v_5){v_8}

      \Edges[color=red](v_2,v_4,v_8,v_5,v_2)
      \Edges[color=red](v_1,v_3,v_6,v_7,v_3)
      \Edges(v_3,v_7)
      \Edges(v_2,v_5)
    \end{tikzpicture}   
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{最小生成树}
  \begin{itemize}
  \item 很多现实问题可以抽象成网。比如,在$n$个城市之间建立通信网,要求总成本最低。
  \item 上述问题是求连通网的最小生成树问题,即挑选$n-1$条不产生回路的最短边,则总成
    本(生成树的各边的权重之和)达到最低。
  \end{itemize}

  \begin{columns}[T]
    \column{0.5\textwidth}
    \scalebox{0.8} {
      \begin{tikzpicture}[n/.style={draw, circle, minimum size=0.5cm}]
        \draw node[n](v3){$v_3$} node[n, above=of v3] (v1) {$v_1$}
        node[n, left=of v3, xshift=-0.5cm,yshift=0.5cm] (v2) {$v_2$} node[n, right=of v3, xshift=0.5cm, yshift=0.5cm] (v4) {$v_4$}
        node[n, below left=of v3] (v5) {$v_5$} node[n, below right=of v3] (v6) {$v_6$};
        \path[draw] (v1) edge node[above]{6} (v2) 
        (v1) edge node[right]{1} (v3) 
        (v1) edge node[above]{5} (v4) 
        (v2) edge node[above]{5} (v3) 
        (v2) edge node[left]{3} (v5) 
        (v4) edge node[above]{5} (v3) 
        (v4) edge node[left]{2} (v6) 
        (v5) edge node[above]{6} (v3) 
        (v5) edge node[above]{6} (v6) 
        (v6) edge node[right] {4} (v3);

        \draw[draw=red!50,thick] (v1) -- (v3) --(v5) --(v2) (v3) --(v6) --(v4);

        \draw node[below=2 of v3]{总成本为16};
      \end{tikzpicture}
    }

    \column{0.5\textwidth}
    \scalebox{0.8}{
      \begin{tikzpicture}[n/.style={draw, circle, minimum size=0.5cm}]
        \draw node[n](v3){$v_3$} node[n, above=of v3] (v1) {$v_1$}
        node[n, left=of v3, xshift=-0.5cm,yshift=0.5cm] (v2) {$v_2$} node[n, right=of v3, xshift=0.5cm, yshift=0.5cm] (v4) {$v_4$}
        node[n, below left=of v3] (v5) {$v_5$} node[n, below right=of v3] (v6) {$v_6$};

        \path[draw] (v1) edge node[above]{6} (v2) 
        (v1) edge node[right]{1} (v3) 
        (v1) edge node[above]{5} (v4) 
        (v2) edge node[above]{5} (v3) 
        (v2) edge node[left]{3} (v5) 
        (v4) edge node[above]{5} (v3) 
        (v4) edge node[left]{2} (v6) 
        (v5) edge node[above]{6} (v3) 
        (v5) edge node[above]{6} (v6) 
        (v6) edge node[right] {4} (v3);

        \draw[draw=red!50,thick] (v3) -- (v1) --(v2) --(v5) -- (v6) --(v4) --(v1);

        \draw node[below=2 of v3]{总成本为23};
      \end{tikzpicture}      
    }
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{最小生成树}
  利用最小生成树的如下性质：

  假设$G=(V, E)$是一个连通图,$U$是顶点集$V$的一个非空子集。若 $(u, v)$是一条具有
  最小权值(代价)的边,其中$u \in U$, $v \in V-U$, 则必存在一棵包含边(u, v)的最小生
  成树。

  \begin{tikzpicture}[]
    \draw node[](ls) {}
    node[] (rs) {};
  \end{tikzpicture}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Prim算法}
  从顶点出发：找连通部分和未连通部分之间的最小代价的一条路

  \begin{tikzpicture}[]
    \draw node[](ls) {}
    node[] (rs) {};
  \end{tikzpicture}
\end{frame}


\begin{frame}[fragile, allowframebreaks]
  \frametitle{Prim MST}
  \begin{minted}[fontsize=\scriptsize]{java}
    public class PrimMST {
      static int minimum(CloseEdge[] closeEdges) {
        int minValue = closeEdges[0].lowcost;
        int minVex = 0;
        for (int i = 1; i < closeEdges.length; i++) {
          int lowcost = closeEdges[i].lowcost;
          if (lowcost > 0 && (lowcost < minValue || minValue == 0)) {
            minValue = lowcost;
            minVex = i;
          }
        }
        return minVex;
      }

      static void mst() {
        CloseEdge[] closeEdges = new CloseEdge[Graph.vexnum];
        closeEdges[0] = new CloseEdge(0, 0);

        //初始化
        for (int i = 1; i < Graph.vexnum; i++) {
          closeEdges[i] = new CloseEdge(0, Graph.arcs[0][i]);
        }

        //默认选中了第0个节点，处理剩余的n-1个
        for (int i = 1; i < Graph.vexnum; i++) {
          int k = minimum(closeEdges);
          String fromVex = Graph.labels[closeEdges[k].adjvex];
          String toVex = Graph.labels[k];

          System.out.println(fromVex + " -> " + toVex);
          closeEdges[k].lowcost = 0;

          //处理每一个Vertex, 看能否通过k让代价更低
          for (int j = 0; j < Graph.vexnum; j++) {
            if (Graph.arcs[k][j] < closeEdges[j].lowcost) {
              closeEdges[j].lowcost = Graph.arcs[k][j];
              closeEdges[j].adjvex = k;
            }
          }
        }
      }

      public static void main(String[] args) {
        mst();
      }

      public static class CloseEdge {
        public int adjvex;
        public int lowcost;

        public CloseEdge(int adjvex, int lowcost) {
          this.adjvex = adjvex;
          this.lowcost = lowcost;
        }
      }


      public static class Graph {
        public static int INFINITE = 10000;

        public static int vexnum = 6;

        public static String[] labels = new String[]{"v1", "v2", "v3",
          "v4", "v5", "v6"};

        public static int[][] arcs = new int[][]{
          {0, 6, 1, 5, INFINITE, INFINITE},
          {6, 0, 5, INFINITE, 3, INFINITE},
          {1, 5, 0, 5, 6, 4},
          {5, INFINITE, 5, 0, INFINITE, 2},
          {0, 3, 6, INFINITE, 0, 6},
          {INFINITE, INFINITE, 4, 2, 6, 0}
        };
      }
    }
  \end{minted}
\end{frame}

\begin{frame}[fragile]
	\frametitle{延伸阅读}
    
    Algorithms Course - Graph Theory Tutorial from a Google Engineer: 
    \url{https://www.youtube.com/watch?v=09_LlHjoEiY}


\end{frame}

\begin{frame}[fragile]
  \frametitle{本章作业}
  \begin{enumerate}
  \item 最小生成树的Prim, Kruscal算法
  \item 最短路径的Dijstra, Floyd算法
  \end{enumerate}

  \begin{itemize}
  \item 编程实现上述算法(务必认真写注释),
  \item 要求显示某图的最小生成树/某两点之间的最短路径;
  \item 基本要求：Prim, Kruscal可以二选一, Dijstra, Floyd可以二选一
  \item 优秀要求：四种算法都实现
  \end{itemize}
\end{frame}
